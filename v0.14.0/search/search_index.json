{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rosetta A blazing fast internationalization (i18n) library for Crystal with compile-time key lookup. You'll never have a missing translation in your app, ever again.","title":"Rosetta"},{"location":"#rosetta","text":"A blazing fast internationalization (i18n) library for Crystal with compile-time key lookup. You'll never have a missing translation in your app, ever again.","title":"Rosetta"},{"location":"configuration/","text":"Configuration Configuration options are defined as annotations to the main Rosetta module in the initializer file. Warning All configuration should happen before calling the Rosetta::Backend.load macro. Rosetta::DefaultLocale Defines the default value if no locale is set. The default default locale is set to :en . @[ Rosetta::DefaultLocale ( \"es-ES\" ) ] module Rosetta end The value can be either a String or a Symbol . Info This value is used by the compiler to define the ruling set of locale keys. Which means that, if one of the other available locales is missing some of the keys found in the default key set, the compiler will complain. So every available locale will need to have the exact same key set as the default locale. Rosetta::AvailableLocales Defines all the available locales, including the default locale. The default for this setting is [\"en\"] . @[ Rosetta::AvailableLocales ( \"de\" , \"en-GB\" , \"en-US\" , \"es\" , \"nl\" ) ] module Rosetta end Rosetta::PluralizationRules Defines a custom mapping of pluralization rules: @[ Rosetta::PluralizationRules ({ en : MyRule , nl : MyRule , }) ] module Rosetta end","title":"Configuration"},{"location":"configuration/#configuration","text":"Configuration options are defined as annotations to the main Rosetta module in the initializer file. Warning All configuration should happen before calling the Rosetta::Backend.load macro.","title":"Configuration"},{"location":"configuration/#rosettadefaultlocale","text":"Defines the default value if no locale is set. The default default locale is set to :en . @[ Rosetta::DefaultLocale ( \"es-ES\" ) ] module Rosetta end The value can be either a String or a Symbol . Info This value is used by the compiler to define the ruling set of locale keys. Which means that, if one of the other available locales is missing some of the keys found in the default key set, the compiler will complain. So every available locale will need to have the exact same key set as the default locale.","title":"Rosetta::DefaultLocale"},{"location":"configuration/#rosettaavailablelocales","text":"Defines all the available locales, including the default locale. The default for this setting is [\"en\"] . @[ Rosetta::AvailableLocales ( \"de\" , \"en-GB\" , \"en-US\" , \"es\" , \"nl\" ) ] module Rosetta end","title":"Rosetta::AvailableLocales"},{"location":"configuration/#rosettapluralizationrules","text":"Defines a custom mapping of pluralization rules: @[ Rosetta::PluralizationRules ({ en : MyRule , nl : MyRule , }) ] module Rosetta end","title":"Rosetta::PluralizationRules"},{"location":"fallbacks/","text":"When working with variations of languages, like en-US or en-GB , it's useful for one locale set to fall back to another one to avoid duplication between your locales sets. Fallback rules Fallback rules are configured using the Rosetta::FallbackRules annotation: @[ Rosetta::AvailableLocales ( \"en-GB\" , \"en-US\" , :nl ) ] @[ Rosetta::FallbackRules ({ \"en-GB\" : \"en-US\" , }) ] In the example above, en-US is treated as the main locale set for English, which should be complete. The en-GB set only needs to include the translations deviating from en-US . Chaining fallbacks Fallbacks may also be chained: @[ Rosetta::AvailableLocales ( \"en-GB\" , \"en-US\" , :en , :nl ) ] @[ Rosetta::FallbackRules ({ \"en-US\" : \"en\" \"en-GB\" : \"en-US\" , }) ] The callback chain will now be en-GB -> en-US -> en . Info It's important to note that fallback rules are applied sequentially. To be able to fall back to a set, it must be \"complete\". That is why, in the example above, en-US is falling back on en first, before en-GB can fall back on en-US .","title":"Fallbacks"},{"location":"fallbacks/#fallback-rules","text":"Fallback rules are configured using the Rosetta::FallbackRules annotation: @[ Rosetta::AvailableLocales ( \"en-GB\" , \"en-US\" , :nl ) ] @[ Rosetta::FallbackRules ({ \"en-GB\" : \"en-US\" , }) ] In the example above, en-US is treated as the main locale set for English, which should be complete. The en-GB set only needs to include the translations deviating from en-US .","title":"Fallback rules"},{"location":"fallbacks/#chaining-fallbacks","text":"Fallbacks may also be chained: @[ Rosetta::AvailableLocales ( \"en-GB\" , \"en-US\" , :en , :nl ) ] @[ Rosetta::FallbackRules ({ \"en-US\" : \"en\" \"en-GB\" : \"en-US\" , }) ] The callback chain will now be en-GB -> en-US -> en . Info It's important to note that fallback rules are applied sequentially. To be able to fall back to a set, it must be \"complete\". That is why, in the example above, en-US is falling back on en first, before en-GB can fall back on en-US .","title":"Chaining fallbacks"},{"location":"getting_started/","text":"Installation 1. Add the dependency to your shard.yml : dependencies : rosetta : github : wout/rosetta 2. Run shards install 3. Run bin/rosetta --init Using Lucky Include rosetta in src/shards.cr : require \"rosetta\" Generate the translations for Avram validations: $ bin / rosetta -- lucky Use the integrate macro in the config/rosetta.cr initializer to include Rosetta::Translatable in every base class where translations are needed: Rosetta :: Lucky . integrate Make sure your tranlations are in place: # config/rosetta/example.en.yml en : hello : show_page : welcome_message : \"Hi %{name}!\" Localize your app: class Hello:: ShowPage < MainLayout def content h1 r ( \".welcome_message\" ) . t ( name : \"Jeremy\" ) # => \"Hi Jeremy!\" end end Rosetta is officially recommended as the localization library for Lucky. For a full tutorial, look at the Lucky Guides . Using Kemal Make sure your tranlations are in place: # config/rosetta/example.en.yml en : welcome_message : \"Hi %{name}!\" Then require \"config/rosetta\" and you're good to go: # e.g. src/app_name.cr require \"kemal\" require \"../config/rosetta\" get \"/\" do Rosetta . find ( \"welcome_message\" ) . t ( name : \"Serdar\" ) # => \"Hi Serdar!\" end Other frameworks First require \"config/rosetta\" in your app, and include the Rosetta::Translatable mixin in the base class of controllers, models, views and anywhere else where you need Rosetta: # e.g. src/app_name.cr require \"../config/rosetta\" abstract class BaseController include Rosetta :: Translatable end Make sure your tranlations are in place: # config/rosetta/example.en.yml en : hello_controller : welcome_message : \"Hi %{name}!\" Localize your app: class HelloController < BaseController def index puts r ( \".welcome_message\" ) . t ( name : \"Brian\" ) # => \"Hi Brian!\" end end","title":"Getting started"},{"location":"getting_started/#installation","text":"1. Add the dependency to your shard.yml : dependencies : rosetta : github : wout/rosetta 2. Run shards install 3. Run bin/rosetta --init","title":"Installation"},{"location":"getting_started/#using-lucky","text":"Include rosetta in src/shards.cr : require \"rosetta\" Generate the translations for Avram validations: $ bin / rosetta -- lucky Use the integrate macro in the config/rosetta.cr initializer to include Rosetta::Translatable in every base class where translations are needed: Rosetta :: Lucky . integrate Make sure your tranlations are in place: # config/rosetta/example.en.yml en : hello : show_page : welcome_message : \"Hi %{name}!\" Localize your app: class Hello:: ShowPage < MainLayout def content h1 r ( \".welcome_message\" ) . t ( name : \"Jeremy\" ) # => \"Hi Jeremy!\" end end Rosetta is officially recommended as the localization library for Lucky. For a full tutorial, look at the Lucky Guides .","title":"Using Lucky"},{"location":"getting_started/#using-kemal","text":"Make sure your tranlations are in place: # config/rosetta/example.en.yml en : welcome_message : \"Hi %{name}!\" Then require \"config/rosetta\" and you're good to go: # e.g. src/app_name.cr require \"kemal\" require \"../config/rosetta\" get \"/\" do Rosetta . find ( \"welcome_message\" ) . t ( name : \"Serdar\" ) # => \"Hi Serdar!\" end","title":"Using Kemal"},{"location":"getting_started/#other-frameworks","text":"First require \"config/rosetta\" in your app, and include the Rosetta::Translatable mixin in the base class of controllers, models, views and anywhere else where you need Rosetta: # e.g. src/app_name.cr require \"../config/rosetta\" abstract class BaseController include Rosetta :: Translatable end Make sure your tranlations are in place: # config/rosetta/example.en.yml en : hello_controller : welcome_message : \"Hi %{name}!\" Localize your app: class HelloController < BaseController def index puts r ( \".welcome_message\" ) . t ( name : \"Brian\" ) # => \"Hi Brian!\" end end","title":"Other frameworks"},{"location":"interpolation/","text":"Arguments and NamedTuple Interpolations can be passed as arguments for the t method: Rosetta . find ( \"user.welcome_message\" ) . t ( name : \"Ary\" ) # => \"Hi Ary!\" A NamedTuple works as well: Rosetta . find ( \"user.welcome_message\" ) . t ({ name : \"Ary\" }) # => \"Hi Ary!\" Important to know here is that translations with interpolation keys will always require you to call the t method with the right number of interpolation keys, or the compiler will complain: # en.user.welcome_message: \"Hi %{name}!\" Rosetta . find ( \"user.welcome_message\" ) . t Error : wrong number of arguments for ' Rosetta :: Locales :: User_WelcomeMessage #t' ( given 0 , expected 1 ) Overloads are : - Rosetta :: Locales :: User_WelcomeMessage #t(name : String) - Rosetta :: Locales :: User_WelcomeMessage #t(values : NamedTuple(name: String)) This is to ensure you're not missing any interpolation values. Time directives If the string in your locale files contains time format directives, Rosetta will require a time object as one of the interpolation arguments and translate the value to the current locale: # es.messages.great_day: \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . find ( \"messages.great_day\" ) . t ( name : \"Brian\" , time : Time . local ) # => \"\u00a1Hola Brian, que tengas un buen domingo!\" Working with a Hash The t method does not accept hashes, only arguments or a NamedTuple . For situations where you have to use a hash, there's the t_hash method: Rosetta . find ( \"user.welcome_message\" ) . t_hash ({ :name => \"Beta\" }) # => \"Hi Beta!\" Warning This method is considered unsafe because the content of hashes can't be checked at compile-time. It's also much slower, because interpolation values are inserted using gsub instead of native string interpolation. So, only use it when there's no other way, and use it with care. The uninterpolated string The raw, uninterpolated string, can be accessed with the raw method: Rosetta . find ( \"user.welcome_message\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Which can then be interpolated later: value = Rosetta . find ( \"messages.great_day\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . interpolate ( value , { name : \"Ary\" , time : Time . local }) # => \"\u00a1Hola Ary, que tengas un buen domingo!\" Warning The Rosetta.interpolate method uses gsub rather than native string interpolation, so it's a lot slower and it doesn't check if all the required interpolation keys are given.","title":"Interpolation"},{"location":"interpolation/#arguments-and-namedtuple","text":"Interpolations can be passed as arguments for the t method: Rosetta . find ( \"user.welcome_message\" ) . t ( name : \"Ary\" ) # => \"Hi Ary!\" A NamedTuple works as well: Rosetta . find ( \"user.welcome_message\" ) . t ({ name : \"Ary\" }) # => \"Hi Ary!\" Important to know here is that translations with interpolation keys will always require you to call the t method with the right number of interpolation keys, or the compiler will complain: # en.user.welcome_message: \"Hi %{name}!\" Rosetta . find ( \"user.welcome_message\" ) . t Error : wrong number of arguments for ' Rosetta :: Locales :: User_WelcomeMessage #t' ( given 0 , expected 1 ) Overloads are : - Rosetta :: Locales :: User_WelcomeMessage #t(name : String) - Rosetta :: Locales :: User_WelcomeMessage #t(values : NamedTuple(name: String)) This is to ensure you're not missing any interpolation values.","title":"Arguments and NamedTuple"},{"location":"interpolation/#time-directives","text":"If the string in your locale files contains time format directives, Rosetta will require a time object as one of the interpolation arguments and translate the value to the current locale: # es.messages.great_day: \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . find ( \"messages.great_day\" ) . t ( name : \"Brian\" , time : Time . local ) # => \"\u00a1Hola Brian, que tengas un buen domingo!\"","title":"Time directives"},{"location":"interpolation/#working-with-a-hash","text":"The t method does not accept hashes, only arguments or a NamedTuple . For situations where you have to use a hash, there's the t_hash method: Rosetta . find ( \"user.welcome_message\" ) . t_hash ({ :name => \"Beta\" }) # => \"Hi Beta!\" Warning This method is considered unsafe because the content of hashes can't be checked at compile-time. It's also much slower, because interpolation values are inserted using gsub instead of native string interpolation. So, only use it when there's no other way, and use it with care.","title":"Working with a Hash"},{"location":"interpolation/#the-uninterpolated-string","text":"The raw, uninterpolated string, can be accessed with the raw method: Rosetta . find ( \"user.welcome_message\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Which can then be interpolated later: value = Rosetta . find ( \"messages.great_day\" ) . raw # => \"\u00a1Hola %{name}, que tengas un buen %A!\" Rosetta . interpolate ( value , { name : \"Ary\" , time : Time . local }) # => \"\u00a1Hola Ary, que tengas un buen domingo!\" Warning The Rosetta.interpolate method uses gsub rather than native string interpolation, so it's a lot slower and it doesn't check if all the required interpolation keys are given.","title":"The uninterpolated string"},{"location":"locale_files/","text":"Locale files en : example : translation : \"Hello world!\" interpolation : \"Hi %{name}, have a great %A!\" nesting : \"%r{example.translation} How are you?\" pluralization : one : \"One item\" other : \"%{count} items\" Chop up your locale files and place them in subdirectories. Use YAML or JSON files, or mix them together. Organise them any way you prefer. Warning Beware, though, that there is a fixed loading order. JSON files are loaded first, then YAML files. So in the unlikely situation where you have the same key in a JSON and a YAML file, YAML will take precedence.","title":"Locale files"},{"location":"locale_files/#locale-files","text":"en : example : translation : \"Hello world!\" interpolation : \"Hi %{name}, have a great %A!\" nesting : \"%r{example.translation} How are you?\" pluralization : one : \"One item\" other : \"%{count} items\" Chop up your locale files and place them in subdirectories. Use YAML or JSON files, or mix them together. Organise them any way you prefer. Warning Beware, though, that there is a fixed loading order. JSON files are loaded first, then YAML files. So in the unlikely situation where you have the same key in a JSON and a YAML file, YAML will take precedence.","title":"Locale files"},{"location":"localization/","text":"Predefined localization formats, day names and month names, live under the rosetta_localization namespace in the locale files. The initializer script will install the required files for you in order to be able to work with Rosetta. Localized time Similar to translations, localization formats are fetched at compile-time and localized at runtime. Rosetta . time . l ( Time . local ) # => \"Sun, 29 Aug 2021 18:30:57 +0200\" This will use the :default format to convert the given Time object. Another predefined format can be passed: Rosetta . time ( :short ) . l ( Time . local ) # => \"29 Aug 18:30\" For specific formats, a string can be passed as well: Rosetta . time ( \"%H:%M:%S\" ) . l ( Time . local ) # => \"18:30:57\" Localized date Rosetta . date . l ( Time . local ) # => \"2021-08-29\" Or with a date-formatted tuple: Rosetta . date . l ({ 1991 , 9 , 17 }) # => \"1991-09-17\" Similar to the time macro, a predefined format can be passed: Rosetta . date ( :long ) . l ( Time . local ) # => \"August 29, 2021\" Or a completely custom format: Rosetta . date ( \"%Y\" ) . l ( Time . local ) # => \"2021\" Localized number Number formats work the same as date and time formats. Rosetta . number . l ( 123_456.789 ) # => \"123,456.79\" With a specific predefined format: Rosetta . number ( :custom ) . l ( 123_456.789 ) # => \"12 34 56.789\" Or with specific formatting options: Rosetta . number . l ( 123_456.789 , decimal_places : 6 ) # => \"123,456.789000\" Info In the background, Rosetta uses Crystal's native Number#format method and accepts the same parameters. Distance of time in words A few helpers are included for translating the distance of time. The distance between two times : Rosetta . distance_of_time_in_words ( Time . utc ( 2021 , 10 , 15 , 8 , 0 , 0 ), Time . utc ( 2021 , 10 , 15 , 8 , 0 , 5 )) ) # => \"5 seconds\" Time ago since a given time : Rosetta . time_ago_in_words ( Time . local - 1 . year ) # => \"about a year\" Time from now to a given time : Rosetta . time_from_now_in_words ( Time . local + 1 . year ) # => \"about a year\" The Localizable mixin Include this mixin anywhere you want to work with localized dates, times and numbers. Here's an example of its usage: class User include Rosetta :: Localizable def birthday r_date ( :short ) . l ( born_at ) end end User . new . birthday # => \"Feb 20\" Similarly there are the r_time and the r_number macros for retrieval, returning a struct which accepts the l method for the value that needs to be localized. The distance_of_time_in_words , time_ago_in_words an time_from_now_in_words helpers are also included with this module.","title":"Date, time and numbers"},{"location":"localization/#localized-time","text":"Similar to translations, localization formats are fetched at compile-time and localized at runtime. Rosetta . time . l ( Time . local ) # => \"Sun, 29 Aug 2021 18:30:57 +0200\" This will use the :default format to convert the given Time object. Another predefined format can be passed: Rosetta . time ( :short ) . l ( Time . local ) # => \"29 Aug 18:30\" For specific formats, a string can be passed as well: Rosetta . time ( \"%H:%M:%S\" ) . l ( Time . local ) # => \"18:30:57\"","title":"Localized time"},{"location":"localization/#localized-date","text":"Rosetta . date . l ( Time . local ) # => \"2021-08-29\" Or with a date-formatted tuple: Rosetta . date . l ({ 1991 , 9 , 17 }) # => \"1991-09-17\" Similar to the time macro, a predefined format can be passed: Rosetta . date ( :long ) . l ( Time . local ) # => \"August 29, 2021\" Or a completely custom format: Rosetta . date ( \"%Y\" ) . l ( Time . local ) # => \"2021\"","title":"Localized date"},{"location":"localization/#localized-number","text":"Number formats work the same as date and time formats. Rosetta . number . l ( 123_456.789 ) # => \"123,456.79\" With a specific predefined format: Rosetta . number ( :custom ) . l ( 123_456.789 ) # => \"12 34 56.789\" Or with specific formatting options: Rosetta . number . l ( 123_456.789 , decimal_places : 6 ) # => \"123,456.789000\" Info In the background, Rosetta uses Crystal's native Number#format method and accepts the same parameters.","title":"Localized number"},{"location":"localization/#distance-of-time-in-words","text":"A few helpers are included for translating the distance of time. The distance between two times : Rosetta . distance_of_time_in_words ( Time . utc ( 2021 , 10 , 15 , 8 , 0 , 0 ), Time . utc ( 2021 , 10 , 15 , 8 , 0 , 5 )) ) # => \"5 seconds\" Time ago since a given time : Rosetta . time_ago_in_words ( Time . local - 1 . year ) # => \"about a year\" Time from now to a given time : Rosetta . time_from_now_in_words ( Time . local + 1 . year ) # => \"about a year\"","title":"Distance of time in words"},{"location":"localization/#the-localizable-mixin","text":"Include this mixin anywhere you want to work with localized dates, times and numbers. Here's an example of its usage: class User include Rosetta :: Localizable def birthday r_date ( :short ) . l ( born_at ) end end User . new . birthday # => \"Feb 20\" Similarly there are the r_time and the r_number macros for retrieval, returning a struct which accepts the l method for the value that needs to be localized. The distance_of_time_in_words , time_ago_in_words an time_from_now_in_words helpers are also included with this module.","title":"The Localizable mixin"},{"location":"nested_keys/","text":"Reusing existing translations Sometimes you may want to reuse values from other translations keys to avoid duplication. That's where nested keys come in handy. Other keys can be referenced using the %r{} directive: en : messages : greeting : \"Hello %r{messages.world}!\" goodbye : \"Goodbye %r{messages.world}!\" world : \"world\" The parser will check the existence of nested keys at compile time and let you know if any of them could not be found. Warning Key nesting does not work recursively, so you can't reference a locale key that in itself references another locale key. It's also not possible to use two nested keys. Please consider creating a PR or opening an issue it that's something you need.","title":"Nested keys"},{"location":"nested_keys/#reusing-existing-translations","text":"Sometimes you may want to reuse values from other translations keys to avoid duplication. That's where nested keys come in handy. Other keys can be referenced using the %r{} directive: en : messages : greeting : \"Hello %r{messages.world}!\" goodbye : \"Goodbye %r{messages.world}!\" world : \"world\" The parser will check the existence of nested keys at compile time and let you know if any of them could not be found. Warning Key nesting does not work recursively, so you can't reference a locale key that in itself references another locale key. It's also not possible to use two nested keys. Please consider creating a PR or opening an issue it that's something you need.","title":"Reusing existing translations"},{"location":"parser_checks/","text":"After loading all locales, the parser does a series of checkes on the given set. Check 1: presence of translations for all locales If the full set of translations is missing for a locale in the configured Rosetta::AvailableLocales annotation, the parser will raise an error similar to the following: Error: Expected to find translations for : \u2023 en \u2023 nl \u2023 fr But missing all translations for : \u2023 fr Check 2: presence of ruling key set in all alternative locales The Rosetta::DefaultLocale annotation will define the key set that should be present in every alternative locale. If keys are missing, you'll get an error like the one below: Error: Missing keys for locale \"nl\" : \u2023 user.first_name \u2023 user.gender.male \u2023 user.gender.female \u2023 user.gender.non_binary Check 3: no additional keys in alternative locales If any of the alternative locales has keys that aren't present in the key set of the Rosetta::DefaultLocale annotation, the parser will raise an error: Error: The \"nl\" locale has unused keys: \u2023 user.name \u2023 user.date_of_birth Check 4: interpolation keys are present in every translation If a translation in the Rosetta::DefaultLocale has one or more interpolation keys, then those interpolation keys should also be present in the alternative locales. If not, an error similar to the following will be raised: Error: Some translations have mismatching interpolation keys: \u2023 nl: \"message.welcome\" should contain \"%{first_name}\" \u2023 nl: \"base.validations.min_max\" should contain \"%{min}\" \u2023 nl: \"base.validations.min_max\" should contain \"%{max}\" \u2023 fr: \"message.welcome\" should contain \"%{first_name}\" Check 5: pluralization tags are present in every translation Every pluralization rule has a Rosetta::Pluralization::CategoryTags annotation defining which tags should be present in every pluralizable translation. If they are not, an error will be raised: Error: Some pluralizable translations are missing category tags: \u2023 en: \"basket.items\" is missing \"one\" \u2023 nl: \"inbox.messages\" is missing \"few\" Check 6: nested keys can be resolved When using nested keys, those keys should be present. If not, an error similar to the following will be raised: Error: Some nested keys could not be resolved: \u2023 en: \"message.welcome\" references missing key \"message.world\"","title":"Parser checks"},{"location":"parser_checks/#check-1-presence-of-translations-for-all-locales","text":"If the full set of translations is missing for a locale in the configured Rosetta::AvailableLocales annotation, the parser will raise an error similar to the following: Error: Expected to find translations for : \u2023 en \u2023 nl \u2023 fr But missing all translations for : \u2023 fr","title":"Check 1: presence of translations for all locales"},{"location":"parser_checks/#check-2-presence-of-ruling-key-set-in-all-alternative-locales","text":"The Rosetta::DefaultLocale annotation will define the key set that should be present in every alternative locale. If keys are missing, you'll get an error like the one below: Error: Missing keys for locale \"nl\" : \u2023 user.first_name \u2023 user.gender.male \u2023 user.gender.female \u2023 user.gender.non_binary","title":"Check 2: presence of ruling key set in all alternative locales"},{"location":"parser_checks/#check-3-no-additional-keys-in-alternative-locales","text":"If any of the alternative locales has keys that aren't present in the key set of the Rosetta::DefaultLocale annotation, the parser will raise an error: Error: The \"nl\" locale has unused keys: \u2023 user.name \u2023 user.date_of_birth","title":"Check 3: no additional keys in alternative locales"},{"location":"parser_checks/#check-4-interpolation-keys-are-present-in-every-translation","text":"If a translation in the Rosetta::DefaultLocale has one or more interpolation keys, then those interpolation keys should also be present in the alternative locales. If not, an error similar to the following will be raised: Error: Some translations have mismatching interpolation keys: \u2023 nl: \"message.welcome\" should contain \"%{first_name}\" \u2023 nl: \"base.validations.min_max\" should contain \"%{min}\" \u2023 nl: \"base.validations.min_max\" should contain \"%{max}\" \u2023 fr: \"message.welcome\" should contain \"%{first_name}\"","title":"Check 4: interpolation keys are present in every translation"},{"location":"parser_checks/#check-5-pluralization-tags-are-present-in-every-translation","text":"Every pluralization rule has a Rosetta::Pluralization::CategoryTags annotation defining which tags should be present in every pluralizable translation. If they are not, an error will be raised: Error: Some pluralizable translations are missing category tags: \u2023 en: \"basket.items\" is missing \"one\" \u2023 nl: \"inbox.messages\" is missing \"few\"","title":"Check 5: pluralization tags are present in every translation"},{"location":"parser_checks/#check-6-nested-keys-can-be-resolved","text":"When using nested keys, those keys should be present. If not, an error similar to the following will be raised: Error: Some nested keys could not be resolved: \u2023 en: \"message.welcome\" references missing key \"message.world\"","title":"Check 6: nested keys can be resolved"},{"location":"pluralization/","text":"Pluralizable locales A pluralization in the locale files may look like the one below: en : example : pluralization : one : \"One item\" other : \"%{count} items\" The parser will interpret a translation as a pluralizable one if it contains a key called other , and its value contains a %{count} interpolation key. Info The zero category tag is a special case because it is optional in almost all pluralization rules. If it is present in the locale files and count is 0 , the value for zero will be used. If not, then Rosetta will fall back to other . Category tags All the short category tags defined by the CLDR are supported: zero one (singular) two (dual) few (paucal) many (also used for fractions if they have a separate class) other (required\u2014general plural form\u2014also used if the language only has a single form) Pluralizable translations For pluralizable translations, the t method will require the count argument, which can be a Float or an Int : Rosetta . find ( \"example.pluralization\" ) . t ( count : 1.0 ) # => \"One item\" Rosetta . find ( \"example.pluralization\" ) . t ( count : 12 ) # => \"12 items\" Pluralization rules Rosetta includes pluralization rules for most of the available locales. They can be found in the repo under src/rosetta/pluralization/rule . Custom pluralization rules Custom rules need to inherit from Rosetta::Pluralization::Rule , define the apply method and define the required CategoryTags annotation. For example: @[ Rosetta::Pluralization::CategoryTags ( :one , :few , :other ) ] struct MyRule < Rosetta :: Pluralization :: Rule def apply ( count : Float | Int ) : Symbol case count when 1 :one when 2 .. 5 :few else :other end end end Info The CategoryTags annotation is used by the parser to check if the required category tags are all present in the pluralizable translations. If the annotation is not defined, the compiler will let you know. Since zero is optional, only include it in the list if it should be required everywhere. In the initializer Rosetta created at setup, register the rule for one or more locales: @[ Rosetta::PluralizationRules ({ en : MyRule , nl : MyRule , }) ] module Rosetta ; end Warning Configuring custom rules should happen before calling the Rosetta::Backend.load macro.","title":"Pluralization"},{"location":"pluralization/#pluralizable-locales","text":"A pluralization in the locale files may look like the one below: en : example : pluralization : one : \"One item\" other : \"%{count} items\" The parser will interpret a translation as a pluralizable one if it contains a key called other , and its value contains a %{count} interpolation key. Info The zero category tag is a special case because it is optional in almost all pluralization rules. If it is present in the locale files and count is 0 , the value for zero will be used. If not, then Rosetta will fall back to other .","title":"Pluralizable locales"},{"location":"pluralization/#category-tags","text":"All the short category tags defined by the CLDR are supported: zero one (singular) two (dual) few (paucal) many (also used for fractions if they have a separate class) other (required\u2014general plural form\u2014also used if the language only has a single form)","title":"Category tags"},{"location":"pluralization/#pluralizable-translations","text":"For pluralizable translations, the t method will require the count argument, which can be a Float or an Int : Rosetta . find ( \"example.pluralization\" ) . t ( count : 1.0 ) # => \"One item\" Rosetta . find ( \"example.pluralization\" ) . t ( count : 12 ) # => \"12 items\"","title":"Pluralizable translations"},{"location":"pluralization/#pluralization-rules","text":"Rosetta includes pluralization rules for most of the available locales. They can be found in the repo under src/rosetta/pluralization/rule .","title":"Pluralization rules"},{"location":"pluralization/#custom-pluralization-rules","text":"Custom rules need to inherit from Rosetta::Pluralization::Rule , define the apply method and define the required CategoryTags annotation. For example: @[ Rosetta::Pluralization::CategoryTags ( :one , :few , :other ) ] struct MyRule < Rosetta :: Pluralization :: Rule def apply ( count : Float | Int ) : Symbol case count when 1 :one when 2 .. 5 :few else :other end end end Info The CategoryTags annotation is used by the parser to check if the required category tags are all present in the pluralizable translations. If the annotation is not defined, the compiler will let you know. Since zero is optional, only include it in the list if it should be required everywhere. In the initializer Rosetta created at setup, register the rule for one or more locales: @[ Rosetta::PluralizationRules ({ en : MyRule , nl : MyRule , }) ] module Rosetta ; end Warning Configuring custom rules should happen before calling the Rosetta::Backend.load macro.","title":"Custom pluralization rules"},{"location":"set_the_current_locale/","text":"Globally If no value is set, the value of the Rosetta.default_locale macro will be used. This macro will look at the Rosetta::DefaultLocale annotation which has :en as the default value. Defining the current locale is done as follows: Rosetta . locale = :es This property accepts a String or a Symbol . But note that the getter variant of this property will always return a string: Rosetta . locale = :nl Rosetta . locale # => \"nl\" If the given locale identifier is not present in the array returned by the Rosetta.available_locales macro, the value of the Rosetta.default_locale macro will be used instead: # Considering @[ Rosetta::DefaultLocale ( :es ) ] module Rosetta ; end # ... Rosetta . locale = :xx Rosetta . locale # => \"es\" Locally Sometimes you may want to use a different locale for a specific part of your code. In that case, use the Rosetta.with_locale method: Rosetta . find ( \"user.first_name\" ) . t # => First name Rosetta . with_locale ( :nl ) do Rosetta . find ( \"user.first_name\" ) . t # => \"Voornaam\" end Rosetta . find ( \"user.first_name\" ) . t # => First name","title":"Set the current locale"},{"location":"set_the_current_locale/#globally","text":"If no value is set, the value of the Rosetta.default_locale macro will be used. This macro will look at the Rosetta::DefaultLocale annotation which has :en as the default value. Defining the current locale is done as follows: Rosetta . locale = :es This property accepts a String or a Symbol . But note that the getter variant of this property will always return a string: Rosetta . locale = :nl Rosetta . locale # => \"nl\" If the given locale identifier is not present in the array returned by the Rosetta.available_locales macro, the value of the Rosetta.default_locale macro will be used instead: # Considering @[ Rosetta::DefaultLocale ( :es ) ] module Rosetta ; end # ... Rosetta . locale = :xx Rosetta . locale # => \"es\"","title":"Globally"},{"location":"set_the_current_locale/#locally","text":"Sometimes you may want to use a different locale for a specific part of your code. In that case, use the Rosetta.with_locale method: Rosetta . find ( \"user.first_name\" ) . t # => First name Rosetta . with_locale ( :nl ) do Rosetta . find ( \"user.first_name\" ) . t # => \"Voornaam\" end Rosetta . find ( \"user.first_name\" ) . t # => First name","title":"Locally"},{"location":"setup/","text":"Setup The bin/rosetta --init command will generate the initial files to get started. 1. An initializer with the following content: # config/rosetta.cr require \"rosetta\" @[ Rosetta::DefaultLocale ( :en ) ] @[ Rosetta::AvailableLocales ( :en ) ] module Rosetta end Rosetta :: Backend . load ( \"config/rosetta\" ) 2. config/rosetta/rosetta.en.yml This file contains localizations required by Rosetta. For every additional locale, you'll need to copy and translate this file. In the future, files for many languages will be included. Please consider contributing your translations. 3. config/locales/example.en.yml An example locale file, which you can modify or delete. For Lucky users The bin/rosetta --lucky command will generate the translations for avram. 4. config/locales/avram.en.yml For every additional locale, you'll need to copy and translate this file.","title":"Setup"},{"location":"setup/#setup","text":"The bin/rosetta --init command will generate the initial files to get started. 1. An initializer with the following content: # config/rosetta.cr require \"rosetta\" @[ Rosetta::DefaultLocale ( :en ) ] @[ Rosetta::AvailableLocales ( :en ) ] module Rosetta end Rosetta :: Backend . load ( \"config/rosetta\" ) 2. config/rosetta/rosetta.en.yml This file contains localizations required by Rosetta. For every additional locale, you'll need to copy and translate this file. In the future, files for many languages will be included. Please consider contributing your translations. 3. config/locales/example.en.yml An example locale file, which you can modify or delete.","title":"Setup"},{"location":"setup/#for-lucky-users","text":"The bin/rosetta --lucky command will generate the translations for avram. 4. config/locales/avram.en.yml For every additional locale, you'll need to copy and translate this file.","title":"For Lucky users"},{"location":"translations/","text":"Lookup Looking up translations is done with the find macro: Rosetta . find ( \"user.name\" ) This will return a struct containing all the translation data for the given key. To get the translation for the currently selected locale, call the t method: Rosetta . find ( \"user.name\" ) . t # => \"User name\" Optionally, you can call to_s or use the struct with string interpolation: Rosetta . find ( \"user.name\" ) . to_s # => \"User name\" \" #{ Rosetta . find ( \"user.name\" ) } \" # => \"User name\" To safely look up a locale key that may or may not exist, the find macro accepts a default value as the second argument: Rosetta . find ( \"non_existanent_key\" , \"default value\" ) . t # => \"default value\" Getting all translations When required, the translations for all locales can be accessed with the translations property: Rosetta . find ( \"user.first_name\" ) . translations # => {en: \"First name\", nl: \"Voornaam\"} The Translatable mixin This mixin makes it more convenient to work with translated values in your classes. Here's an example of its usage: Rosetta . locale = :es class User include Rosetta :: Translatable def name_label r ( \"user.name_label\" ) . t end end User . new . name_label # => \"Nombre\" The r macro essentially is an alias for the Rosetta.find macro, but it introduces the possibility to use inferred locale keys. By omitting the prefix of the locale key and having the key start with a . , the key prefix will be derived from the current class name: class User include Rosetta :: Translatable def name_label r ( \".name_label\" ) . t # => resolves to \"user.name_label\" end end This also works with nested class names, for example: User => \"user\" Components::MainMenu => \"components.main_menu\" Helpers::SiteSections::UserSettings => \"helpers.site_sections.user_settings\" Using inferred locale keys has an added bonus. You don't need to think about how to organise your locale files. And it also makes finding your keys a lot easier. Finally, in case you want to use another prefix for the current class, an annotation can be used: @[ Rosetta::Translatable::Config ( prefix : \"guest\" ) ] class User include Rosetta :: Translatable def name_label r ( \".name_label\" ) . t # => resolves to \"guest.name_label\" end end Just like the global Rosetta.find marco, interpolations are passed using the t method: class User include Rosetta :: Translatable def welcome_message r ( \".welcome_message\" ) . t ( name : \"Ary\" ) end end The r macro uses Rosetta.find to get the translations for a given key at compile-time. Then the t method translates the value at runtime.","title":"Translations"},{"location":"translations/#lookup","text":"Looking up translations is done with the find macro: Rosetta . find ( \"user.name\" ) This will return a struct containing all the translation data for the given key. To get the translation for the currently selected locale, call the t method: Rosetta . find ( \"user.name\" ) . t # => \"User name\" Optionally, you can call to_s or use the struct with string interpolation: Rosetta . find ( \"user.name\" ) . to_s # => \"User name\" \" #{ Rosetta . find ( \"user.name\" ) } \" # => \"User name\" To safely look up a locale key that may or may not exist, the find macro accepts a default value as the second argument: Rosetta . find ( \"non_existanent_key\" , \"default value\" ) . t # => \"default value\"","title":"Lookup"},{"location":"translations/#getting-all-translations","text":"When required, the translations for all locales can be accessed with the translations property: Rosetta . find ( \"user.first_name\" ) . translations # => {en: \"First name\", nl: \"Voornaam\"}","title":"Getting all translations"},{"location":"translations/#the-translatable-mixin","text":"This mixin makes it more convenient to work with translated values in your classes. Here's an example of its usage: Rosetta . locale = :es class User include Rosetta :: Translatable def name_label r ( \"user.name_label\" ) . t end end User . new . name_label # => \"Nombre\" The r macro essentially is an alias for the Rosetta.find macro, but it introduces the possibility to use inferred locale keys. By omitting the prefix of the locale key and having the key start with a . , the key prefix will be derived from the current class name: class User include Rosetta :: Translatable def name_label r ( \".name_label\" ) . t # => resolves to \"user.name_label\" end end This also works with nested class names, for example: User => \"user\" Components::MainMenu => \"components.main_menu\" Helpers::SiteSections::UserSettings => \"helpers.site_sections.user_settings\" Using inferred locale keys has an added bonus. You don't need to think about how to organise your locale files. And it also makes finding your keys a lot easier. Finally, in case you want to use another prefix for the current class, an annotation can be used: @[ Rosetta::Translatable::Config ( prefix : \"guest\" ) ] class User include Rosetta :: Translatable def name_label r ( \".name_label\" ) . t # => resolves to \"guest.name_label\" end end Just like the global Rosetta.find marco, interpolations are passed using the t method: class User include Rosetta :: Translatable def welcome_message r ( \".welcome_message\" ) . t ( name : \"Ary\" ) end end The r macro uses Rosetta.find to get the translations for a given key at compile-time. Then the t method translates the value at runtime.","title":"The Translatable mixin"},{"location":"variants/","text":"Runtime variants When working with html selects or lists from a database that need translating, it's not possible to use compile-time key lookup. That's where variants come in. Variants are similar to pluralizations as in that they're a locale key containing multiple values: en : color_variants : pink : \"Millennial pink\" teal : \"Deep teal\" yellow : \"Bright yellow\" If the key name contains the _variants suffix, Rosetta will treat it as a translation with variants. They t() method for translations with variants will then require a variant argument: Rosetta . find ( \"color_variants\" ) . t ( variant : \"pink\" ) # => \"Millennial pink\" One disadvantage of variants is that their lookup happens at runtime, so you'll have to make sure all variants are present in the locale files. Compile-time variants Runtime variants can be avoided if the variant keys are known at compile-time. Given the following translations: en : colors : pink : \"Millennial pink\" teal : \"Deep teal\" yellow : \"Bright yellow\" A macro can be used to build the locale keys: {% begin %} {% for variant in %w[pink teak yellow] %} Rosetta . find ( \"colors.{{variant.id}}\" ) . t {% end %} {% end %}","title":"Variants"},{"location":"variants/#runtime-variants","text":"When working with html selects or lists from a database that need translating, it's not possible to use compile-time key lookup. That's where variants come in. Variants are similar to pluralizations as in that they're a locale key containing multiple values: en : color_variants : pink : \"Millennial pink\" teal : \"Deep teal\" yellow : \"Bright yellow\" If the key name contains the _variants suffix, Rosetta will treat it as a translation with variants. They t() method for translations with variants will then require a variant argument: Rosetta . find ( \"color_variants\" ) . t ( variant : \"pink\" ) # => \"Millennial pink\" One disadvantage of variants is that their lookup happens at runtime, so you'll have to make sure all variants are present in the locale files.","title":"Runtime variants"},{"location":"variants/#compile-time-variants","text":"Runtime variants can be avoided if the variant keys are known at compile-time. Given the following translations: en : colors : pink : \"Millennial pink\" teal : \"Deep teal\" yellow : \"Bright yellow\" A macro can be used to build the locale keys: {% begin %} {% for variant in %w[pink teak yellow] %} Rosetta . find ( \"colors.{{variant.id}}\" ) . t {% end %} {% end %}","title":"Compile-time variants"},{"location":"why_rosetta/","text":"Why use Rosetta? You'll never have a missing translation Rosetta is different from other internationalization libraries because it handles key lookup at compile-time rather than runtime. The significant advantage is that you'll be able to find missing translations - or typos in your locale keys - during development rather than after you've deployed your app. This is also true for translation keys in all additional locales. You'll never have a missing interpolation In Rosetta, interpolation keys are arguments to the translation method. So if you're missing an argument, the compiler will complain. The parser will also compare interpolation keys in additional locales to the ones found in the default locale, and let you know if some are missing. Rosetta is 12x faster than similar libraries Benchmarking against other libraries which also use YAML or JSON backends, Rosetta is more than 12x faster than any other one. For simple translations: i18n.cr translation 303.57k ( 3.29\u00b5s) (\u00b1 4.62%) 801B/op 702.21\u00d7 slower i18n translation 18.07M ( 55.35ns) (\u00b1 7.28%) 48.0B/op 12.39\u00d7 slower lens translation 5.09M (196.47ns) (\u00b1 4.60%) 176B/op 43.98\u00d7 slower rosetta translation 223.86M ( 4.47ns) (\u00b1 2.20%) 0.0B/op fastest For translations with interpolations: i18n.cr interpolation 318.12k ( 3.14\u00b5s) (\u00b1 0.85%) 801B/op 108.51\u00d7 slower i18n interpolation 65.55k ( 15.26\u00b5s) (\u00b1 1.01%) 28.2kB/op 664.37\u00d7 slower lens interpolation 2.04M (490.17ns) (\u00b1 1.35%) 565B/op 21.35\u00d7 slower rosetta interpolation 43.55M ( 22.96ns) (\u00b1 4.81%) 80.0B/op fastest Rosetta is that much faster because a lot of the hard work happens at compile-time, and the majority of the data is stored on the stack rather than the heap , out of the scope of garbage collector. Info Libraries used in benchmarks are crimson-knight/i18n.cr , crystal-i18n/i18n and syeopite/lens .","title":"Why Rosetta?"},{"location":"why_rosetta/#why-use-rosetta","text":"","title":"Why use Rosetta?"},{"location":"why_rosetta/#youll-never-have-a-missing-translation","text":"Rosetta is different from other internationalization libraries because it handles key lookup at compile-time rather than runtime. The significant advantage is that you'll be able to find missing translations - or typos in your locale keys - during development rather than after you've deployed your app. This is also true for translation keys in all additional locales.","title":"You'll never have a missing translation"},{"location":"why_rosetta/#youll-never-have-a-missing-interpolation","text":"In Rosetta, interpolation keys are arguments to the translation method. So if you're missing an argument, the compiler will complain. The parser will also compare interpolation keys in additional locales to the ones found in the default locale, and let you know if some are missing.","title":"You'll never have a missing interpolation"},{"location":"why_rosetta/#rosetta-is-12x-faster-than-similar-libraries","text":"Benchmarking against other libraries which also use YAML or JSON backends, Rosetta is more than 12x faster than any other one. For simple translations: i18n.cr translation 303.57k ( 3.29\u00b5s) (\u00b1 4.62%) 801B/op 702.21\u00d7 slower i18n translation 18.07M ( 55.35ns) (\u00b1 7.28%) 48.0B/op 12.39\u00d7 slower lens translation 5.09M (196.47ns) (\u00b1 4.60%) 176B/op 43.98\u00d7 slower rosetta translation 223.86M ( 4.47ns) (\u00b1 2.20%) 0.0B/op fastest For translations with interpolations: i18n.cr interpolation 318.12k ( 3.14\u00b5s) (\u00b1 0.85%) 801B/op 108.51\u00d7 slower i18n interpolation 65.55k ( 15.26\u00b5s) (\u00b1 1.01%) 28.2kB/op 664.37\u00d7 slower lens interpolation 2.04M (490.17ns) (\u00b1 1.35%) 565B/op 21.35\u00d7 slower rosetta interpolation 43.55M ( 22.96ns) (\u00b1 4.81%) 80.0B/op fastest Rosetta is that much faster because a lot of the hard work happens at compile-time, and the majority of the data is stored on the stack rather than the heap , out of the scope of garbage collector. Info Libraries used in benchmarks are crimson-knight/i18n.cr , crystal-i18n/i18n and syeopite/lens .","title":"Rosetta is 12x faster than similar libraries"}]}